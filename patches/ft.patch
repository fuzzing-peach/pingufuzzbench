diff --git a/fuzztruction-experiments b/fuzztruction-experiments
index ffaaeaf..d1c7d1f 160000
--- a/fuzztruction-experiments
+++ b/fuzztruction-experiments
@@ -1 +1 @@
-Subproject commit ffaaeaf8ce9d6c34dd9b8f3e6c065c97e9baf1d8
+Subproject commit d1c7d1f25ec6cd1456e1bb6fe4cfa9257eaea159
diff --git a/fuzztruction_shared/src/util.rs b/fuzztruction_shared/src/util.rs
index 0d07540..f2989a8 100644
--- a/fuzztruction_shared/src/util.rs
+++ b/fuzztruction_shared/src/util.rs
@@ -2,6 +2,7 @@ use anyhow::{anyhow, Result};
 use log::log_enabled;
 use nix::{
     sys::signal::Signal,
+    sys::wait::{waitpid, WaitPidFlag, WaitStatus},
     unistd::{close, Pid},
 };
 use std::{
@@ -12,7 +13,7 @@ use std::{
         Arc,
     },
     thread,
-    time::Duration,
+    time::{Duration, Instant},
 };
 use syscalls::{syscall2, Sysno};
 
@@ -91,26 +92,26 @@ pub fn current_log_level() -> log::Level {
 pub fn wait_pid_timeout(
     pid: i32,
     timeout: Option<Duration>,
-) -> Result<Option<nix::sys::wait::WaitStatus>> {
-    let fd: i32 = match unsafe { syscall2(Sysno::pidfd_open, pid.try_into().unwrap(), 0) } {
-        Ok(fd) => fd.try_into().unwrap(),
-        err @ Err(_) => return Err(anyhow!("Error while calling pidfd_open: {:?}", err)),
-    };
-
-    let _fd_guard = scopeguard::guard(fd, |v| close(v).unwrap());
-
-    let mut pollable_fds = vec![filedescriptor::pollfd {
-        fd: fd.try_into().unwrap(),
-        events: filedescriptor::POLLIN,
-        revents: 0,
-    }];
-
-    match filedescriptor::poll(&mut pollable_fds, timeout) {
-        Ok(_) => {
-            let wait_status = nix::sys::wait::waitpid(Pid::from_raw(pid), None)?;
-            Ok(Some(wait_status))
+) -> Result<Option<WaitStatus>, anyhow::Error> {
+    let pid = Pid::from_raw(pid);
+    let start_time = Instant::now();
+
+    loop {
+        match waitpid(pid, Some(WaitPidFlag::WNOHANG)) {
+            Ok(WaitStatus::StillAlive) => {
+                // 进程仍在运行，检查是否超时
+                if let Some(timeout) = timeout {
+                    if start_time.elapsed() >= timeout {
+                        return Err(anyhow::anyhow!("Timeout while waiting for pid: {}", pid));
+                    }
+                }
+                // 短暂睡眠以减少 CPU 使用
+                std::thread::sleep(Duration::from_millis(10));
+            }
+            Ok(status) => return Ok(Some(status)), // 进程已结束
+            Err(nix::Error::ECHILD) => return Ok(None), // 没有子进程
+            Err(e) => return Err(anyhow::anyhow!("Error while waiting for pid: {}", e)),
         }
-        Err(_) => Ok(None),
     }
 }
 
diff --git a/generator/agent/src/agent.rs b/generator/agent/src/agent.rs
index 4ef436a..049dfef 100644
--- a/generator/agent/src/agent.rs
+++ b/generator/agent/src/agent.rs
@@ -373,6 +373,10 @@ fn run(agent: &mut Agent, _msg: &RunMessage) -> ProcessType {
             // Prevent the child from messing with the mutation cache. However, keep it mapped,
             // for accessing the mutation masks and updating runtime vars.
             agent.mutation_cache.make_private().unwrap();
+
+            std::env::set_var("FAKETIME", "@2024-08-01 00:00:00");
+            std::env::set_var("FAKE_RANDOM", "1");
+
             return ProcessType::CHILD;
         }
 
diff --git a/generator/pass/fuzztruction-source-clang-fast.c b/generator/pass/fuzztruction-source-clang-fast.c
index 47294d0..45bd76d 100644
--- a/generator/pass/fuzztruction-source-clang-fast.c
+++ b/generator/pass/fuzztruction-source-clang-fast.c
@@ -36,12 +36,20 @@ typedef struct {
 
 const char* PASS_SO_NAME = "fuzztruction-source-llvm-pass.so";
 char *pass_path;
+char generator_agent_linkage[1024];
 
 void find_pass()
 {
     char *guess;
     char *cwd;
 
+    char *pass_path_env = getenv("LLVM_PASS_SO");
+    if (pass_path_env != NULL && !access(pass_path_env, R_OK))
+    {
+        pass_path = pass_path_env;
+        goto done;
+    }
+
     cwd = getcwd(NULL, 0);
     if (!cwd) {
         PFATAL("Failed to get CWD");
@@ -163,7 +171,16 @@ args_t* rewrite_argv(const char *argv[], int argc, arg_settings_t* arg_settings)
     }
 
     // Link against our agent that is called by a call our pass injected into main().
-    self->argv[self->argc++] = "-L/home/user/fuzztruction/target/debug";
+    char *generator_agent_dir = getenv("GENERATOR_AGENT_SO_DIR");
+    if (generator_agent_dir != NULL)
+    {
+        sprintf(generator_agent_linkage, "-L%s", generator_agent_dir);
+        self->argv[self->argc++] = generator_agent_linkage;
+    }
+    else
+    {
+        self->argv[self->argc++] = "-L/home/user/fuzztruction/target/debug";
+    }
     self->argv[self->argc++] = "-lgenerator_agent";
     self->argv[self->argc++] = "-DNDEBUG";
 
diff --git a/generator/pass/fuzztruction-source-llvm-pass.cc b/generator/pass/fuzztruction-source-llvm-pass.cc
index f275c54..27fef89 100644
--- a/generator/pass/fuzztruction-source-llvm-pass.cc
+++ b/generator/pass/fuzztruction-source-llvm-pass.cc
@@ -281,7 +281,9 @@ bool FuzztructionSourcePass::initializeFuzzingStub(Module &M) {
 
 
 /*
-Delete call if one of the functions specified by name is called
+Delete call if one of the functions specified by name is called.
+
+In fact, the FT_NOP_FN is not used in FT-Net experiments. So no functions will be deleted~
 */
 bool FuzztructionSourcePass::maybeDeleteFunctionCall(Module &M, CallInst *call_ins, std::set<std::string> &target_functions) {
     Function *callee = call_ins->getCalledFunction();
@@ -351,7 +353,12 @@ uint64_t get_alloction_size_in_bits(AllocaInst *ins, Value *target) {
     }
 }
 
-
+/***
+ * Instrument custom patch points.
+ * 
+ * Randomly mutate the byte returns by the __ft_get_byte, using patchpoint.
+ * But actually, the __ft_get_byte(s) is not used in FT-Net
+ */
 bool FuzztructionSourcePass::instrumentCustomPatchPoints(Module &M, Function *stackmap_intr) {
     auto custom_patch_points_enables = env_var_set("FT_CUSTOM_PATCH_POINTS");
 
@@ -387,7 +394,9 @@ bool FuzztructionSourcePass::instrumentCustomPatchPoints(Module &M, Function *st
     return true;
 }
 
-
+/**
+ * Instrument the entry block of a function to randomly select a target function and inject it.
+ */
 bool FuzztructionSourcePass::instrumentFunctionEntry(Function &instrumented_function, Function *stackmap_intr) {
     auto call_injection_enabled = env_var_set("FT_CALL_INJECTION");
     if (!call_injection_enabled || instrumented_function.isVarArg()) {
@@ -620,6 +629,21 @@ bool FuzztructionSourcePass::instrumentInsArg(Module &M, Function *stackmap_intr
     return true;
 }
 
+/***
+ * Instrument a call instruction.
+ * 
+ * Insert a patchpoint before the call instruction to decide whether the call should be executed or not.
+ *  Head
+ * cond = alloca
+ * store cond, true
+ * patchpoint(cond, 1)
+ * mutated_cond = load cond
+    if (mutated_cond)
+    {
+        Original Call Instruction
+    }
+    Tail
+ */
 bool FuzztructionSourcePass::instrumentCall(Module &M, Function *stackmap_intr, CallInst *call) {
     if (!call->user_empty())
         return false;
@@ -741,6 +765,9 @@ bool FuzztructionSourcePass::injectPatchPoints(Module &M) {
             }
     }
 
+    /**
+     * may delete calls to abort() like termination function specified in abort_fn_callees.
+     */
     for (auto call_ins: abort_fn_callees) {
         dbgs() << "Deleting call to abort " << *call_ins << "\n";
         auto bb = call_ins->getParent();
diff --git a/lib/jail/src/jail.rs b/lib/jail/src/jail.rs
index 3aa7cd0..c3331b0 100644
--- a/lib/jail/src/jail.rs
+++ b/lib/jail/src/jail.rs
@@ -118,12 +118,13 @@ impl Jail {
         // Mount the bear minimum to allow execution of software.
 
         // Mount / into our new root
-        Jail::mount(&["--bind", "-o", "-ro", "/", &self.new_root])
+        Jail::mount(&["--bind", "-o", "ro", "/", &self.new_root])
             .context("Failed to mount / into new root")?;
         Jail::remount_bind_mount_ro(&self.new_root).context("Failed to remount / as ro")?;
 
         let default_ro_source_dirs = [
-            "/home/user/fuzztruction",
+            "/home/user/profuzzbench",
+            "/home/user/fuzztruction-net",
             "/etc/hosts",
             "/etc/hostname",
             "/etc/resolv.conf",
@@ -134,8 +135,8 @@ impl Jail {
             Jail::remount_bind_mount_ro(&dst).context("Failed to remount as ro")?;
         }
 
-        let dst = format!("{}{}", &self.new_root, "/home/user/fuzztruction/eval-result");
-        Jail::mount(&["--bind",  "/home/user/fuzztruction/eval-result", &dst]).context("Failed to mount eval-result RW")?;
+        let dst = format!("{}{}", &self.new_root, "/home/user/fuzztruction-net/eval-result");
+        Jail::mount(&["--bind",  "/home/user/fuzztruction-net/eval-result", &dst]).context("Failed to mount eval-result RW")?;
 
         // Mount /proc, /sys and /dev. These are shared since they are also marked as shared in the "parent" namespace.
         Jail::mount(&["-o", "bind", "/proc", &format!("{}/proc", self.new_root)])
diff --git a/scheduler/src/checks.rs b/scheduler/src/checks.rs
index 2689dde..68c2bd8 100644
--- a/scheduler/src/checks.rs
+++ b/scheduler/src/checks.rs
@@ -132,12 +132,12 @@ fn check_mqueue_queues_max() -> Result<()> {
 pub fn check_system() -> Result<()> {
     check_core_pattern_is_core()?;
     check_fs_suid_dumpable()?;
-    check_if_tmp_is_tmpfs()?;
+    // check_if_tmp_is_tmpfs()?;
     check_if_agent_is_in_path()?;
-    check_scaling_governor()?;
-    check_perf_event_paranoid()?;
-    check_file_limit()?;
-    check_mqueue_queues_max()?;
+    // check_scaling_governor()?;
+    // check_perf_event_paranoid()?;
+    // check_file_limit()?;
+    // check_mqueue_queues_max()?;
     Ok(())
 }
 
diff --git a/scheduler/src/cli/fuzztruction.rs b/scheduler/src/cli/fuzztruction.rs
index eb8c21d..499e9e9 100644
--- a/scheduler/src/cli/fuzztruction.rs
+++ b/scheduler/src/cli/fuzztruction.rs
@@ -358,6 +358,38 @@ fn parse_args() -> ArgMatches {
             Command::new("dump-stackmap")
                 .about("Dump the LLVM stackmap (e.g., locations and sizes)")
         )
+        .subcommand(
+            Command::new("gcov")
+                .about("Run gcov for each insteresting input found.")
+                .arg(
+                    Arg::new("timeout")
+                        .help("Timeout after that a testcase is considered hanging and skipped in consequence")
+                        .short('t')
+                        .long("timeout")
+                        .takes_value(true)
+                        .default_value("1s"),
+                ).arg(
+                    Arg::new("delete")
+                    .long("delete")
+                    .short('d')
+                    .help("Rerun the coverage computation and delete previous results, if any")
+                    .action(clap::ArgAction::SetTrue)
+                ).arg(
+                    Arg::new("replay-step")
+                        .help("Replay the inputs found in the given step. If $i % $replay_step == 0, the input is replayed.")
+                        .short('r')
+                        .long("replay-step")
+                        .takes_value(true)
+                        .default_value("1"),
+                ).arg(
+                    Arg::new("gcov-step")
+                        .help("Run gcov for each insteresting input found in the given step. If $i % $gcov_step == 0, gcov is run.")
+                        .short('g')
+                        .long("gcov-step")
+                        .takes_value(true)
+                        .default_value("1"),
+                )
+        )
         .subcommand(
             Command::new("test-patchpoints")
             .about("Test the patchpoints of the source application (for debugging)")
@@ -387,10 +419,18 @@ fn check_workdir(config: &mut Config, matches: &ArgMatches) -> Result<()> {
     // Purge the working directory if requested.
     if config.general.work_dir.exists() && expects_empty_dir {
         if purge_flag {
-            std::fs::remove_dir_all(&config.general.work_dir).unwrap_or_else(|_| {
-                panic!("Failed to remove workdir {:?}", config.general.work_dir)
+            let dir_entries = std::fs::read_dir(&config.general.work_dir).unwrap_or_else(|_| {
+                panic!("Failed to read workdir {:?}", config.general.work_dir)
             });
-            std::fs::create_dir_all(&config.general.work_dir)?;
+            for entry in dir_entries {
+                let entry = entry.unwrap();
+                let path = entry.path();
+                if path.is_dir() {
+                    std::fs::remove_dir_all(path).unwrap();
+                } else {
+                    std::fs::remove_file(path).unwrap();
+                }
+            }
         } else {
             return Err(anyhow!(
                 "Workdir {:?} exists and --purge was not provided!",
@@ -507,6 +547,10 @@ fn real_main() -> Result<()> {
             handler::handle_cli_llvm_cov_subcommand(llvm_cov_matches, &config)
                 .expect("Failed to run llvm-cov subcommand");
         }
+        Some(("gcov", matches)) => {
+            handler::handle_cli_gcov_subcommand(matches, &config)
+                .expect("Failed to run gcov subcommand");
+        }
         Some(("aflnet", matches)) => {
             handler::handle_cli_aflnet_subcommand(matches, &config)
                 .expect("Failed to run AFLNet mode");
diff --git a/scheduler/src/cli/handler.rs b/scheduler/src/cli/handler.rs
index e98c37a..84ccd01 100644
--- a/scheduler/src/cli/handler.rs
+++ b/scheduler/src/cli/handler.rs
@@ -1,4 +1,7 @@
 use std::{
+    fs,
+    path::Path,
+    process::{Command, Stdio},
     sync::{self, atomic::AtomicBool, Arc},
     time::{Duration, Instant},
 };
@@ -271,6 +274,64 @@ pub(crate) fn handle_cli_sgfuzz_subcommand(matches: &ArgMatches, config: &Config
     Ok(())
 }
 
+// Recursively delete all the gcda files in the src-dir
+pub fn cleanup_gcda(dir: &Path) -> std::io::Result<()> {
+    if dir.is_dir() {
+        for entry in fs::read_dir(dir)? {
+            let entry = entry?;
+            let path = entry.path();
+            if path.is_dir() {
+                cleanup_gcda(&path)?;
+            } else if let Some(extension) = path.extension() {
+                if extension == "gcda" {
+                    fs::remove_file(path)?;
+                }
+            }
+        }
+    }
+    Ok(())
+}
+
+pub(crate) fn handle_cli_gcov_subcommand(
+    trace_matches: &ArgMatches,
+    config: &Config,
+) -> Result<()> {
+    let termination_flag = register_on_termination_flag();
+    let timeout = trace_matches
+        .value_of("timeout")
+        .map(|e| e.parse::<CliDuration>().unwrap())
+        .map(|v| v.0)
+        .unwrap();
+
+    if trace_matches.get_flag("delete") {
+        cleanup_gcda(config.gcov.as_ref().unwrap().src_dir.as_ref())?;
+    }
+    let replay_step: u32 = trace_matches
+        .value_of("replay-step")
+        .map(|v| v.parse().unwrap())
+        .unwrap_or(1);
+    let gcov_step: u32 = trace_matches
+        .value_of("gcov-step")
+        .map(|v| v.parse().unwrap())
+        .unwrap_or(1);
+
+    log::info!("Timeout is set to {timeout:?}");
+
+    coverage::networked::compute_gcov(
+        config,
+        termination_flag.clone(),
+        timeout,
+        replay_step,
+        gcov_step,
+    )?;
+
+    if termination_flag.load(std::sync::atomic::Ordering::SeqCst) {
+        return Ok(());
+    }
+
+    Ok(())
+}
+
 pub(crate) fn handle_cli_llvm_cov_subcommand(
     trace_matches: &ArgMatches,
     config: &Config,
diff --git a/scheduler/src/competitors/stateafl.rs b/scheduler/src/competitors/stateafl.rs
index 2a2727a..cb7cf69 100644
--- a/scheduler/src/competitors/stateafl.rs
+++ b/scheduler/src/competitors/stateafl.rs
@@ -47,13 +47,14 @@ impl StateAflWorker {
 
     fn _loop(self, init_finished: mpsc::Sender<()>) {
         let stateafl_config = self
-            .config
-            .stateafl
-            .as_ref()
-            .expect("Target has no StateAfl config");
-
-        let seed_dir = stateafl_config.input_dir.clone();
-        let workdir = self.config.general.stateafl_workdir();
+        .config
+        .stateafl
+        .as_ref()
+        .expect("Target has no StateAfl config");
+    
+    let seed_dir = stateafl_config.input_dir.clone();
+    let workdir = self.config.general.stateafl_workdir();
+    println!("workdir: {:?}", workdir);
         fs::create_dir_all(&workdir).unwrap();
 
         let mut log_path = workdir.clone();
@@ -70,7 +71,7 @@ impl StateAflWorker {
             .unwrap();
         let log_fd = log_file.into_raw_fd();
 
-        let mut cmd = Command::new("/competitors/stateafl/afl-fuzz");
+        let mut cmd = Command::new("/home/user/stateafl/afl-fuzz");
 
         unsafe {
             cmd.stdout(Stdio::from_raw_fd(log_fd));
@@ -211,12 +212,12 @@ impl StateAflWorker {
             cmd.gid(jail_uid_gid.1);
         }
 
-        OpenOptions::new()
-            .write(true)
-            .open("/proc/sys/kernel/randomize_va_space")
-            .unwrap()
-            .write_all("0".as_bytes())
-            .unwrap();
+        // OpenOptions::new()
+        //     .write(true)
+        //     .open("/proc/sys/kernel/randomize_va_space")
+        //     .unwrap()
+        //     .write_all("0".as_bytes())
+        //     .unwrap();
 
         let mut child = None;
         for try_idx in 0..6 {
@@ -263,7 +264,7 @@ impl StateAflWorker {
     pub fn run(self) -> WorkerProxy {
         let (init_finshied_sender, init_finshied_receiver) = mpsc::channel::<()>();
         let handle = thread::spawn(|| {
-            unshare_network_namespace(&self.config);
+            // unshare_network_namespace(&self.config);
             self._loop(init_finshied_sender)
         });
         init_finshied_receiver
diff --git a/scheduler/src/config.rs b/scheduler/src/config.rs
index 036e283..c3c61df 100644
--- a/scheduler/src/config.rs
+++ b/scheduler/src/config.rs
@@ -289,6 +289,14 @@ pub struct StateAflConfig {
     pub enable_state_aware_mode: bool,
 }
 
+#[derive(Debug, Clone, Serialize)]
+pub struct GcovConfig {
+    pub bin_path: PathBuf,
+    pub env: Vec<(String, String)>,
+    pub src_dir: PathBuf,
+    pub reporter: String,
+}
+
 #[derive(Debug, Clone, Serialize)]
 pub struct VanillaConfig {
     /// Environment used during binary
@@ -444,6 +452,8 @@ pub struct Config {
     pub stateafl: Option<StateAflConfig>,
     /// Config for the SGFuzz fuzzer.
     pub sgfuzz: Option<SGFuzzConfig>,
+    
+    pub gcov: Option<GcovConfig>
 }
 
 impl Config {
@@ -1028,6 +1038,7 @@ impl ConfigBuilder {
                 "sink-cov",
                 "source",
                 "afl-net",
+                "gcov",
                 "state-afl",
                 "sgfuzz",
                 "vanilla",
@@ -1290,6 +1301,22 @@ impl ConfigBuilder {
         })
     }
 
+    fn parse_gcov_section(&self, yaml: &Yaml) -> Result<GcovConfig> {
+        let bin_path = self.get_attribute(yaml, "bin-path")?;
+        let env: Option<Vec<(String, String)>> = self.get_attribute(yaml, "env")?;
+        let env = env.unwrap_or_default();
+        let src_dir = self.get_attribute(yaml, "src-dir")?;
+        let reporter = self.get_attribute(yaml, "reporter")?;
+        ConfigBuilder::check_for_unparsed_keys(yaml, &["bin-path", "env", "src-dir", "reporter"])?;
+
+        Ok(GcovConfig {
+            bin_path,
+            env,
+            src_dir,
+            reporter,
+        })
+    }
+
     fn parse_state_afl_section(&self, yaml: &Yaml) -> Result<StateAflConfig> {
         let bin_path = self.get_attribute(yaml, "bin-path")?;
         let env: Option<Vec<(String, String)>> = self.get_attribute(yaml, "env")?;
@@ -1477,6 +1504,13 @@ impl ConfigBuilder {
             Some(self.parse_afl_net_section(aflnet_section)?)
         };
 
+        let gcov_section = &yaml["gcov"];
+        let gcov_config = if gcov_section.is_null() || gcov_section.is_badvalue() {
+            None
+        } else {
+            Some(self.parse_gcov_section(gcov_section)?)
+        };
+
         let stateafl_section = &yaml["state-afl"];
         let stateafl_section = if stateafl_section.is_badvalue() {
             None
@@ -1508,6 +1542,7 @@ impl ConfigBuilder {
             sgfuzz: sgfuzz_section,
             sink_cov: sink_cov_config,
             vanilla: vanilla_config,
+            gcov: gcov_config
         };
         config.validate()?;
         Ok(config)
diff --git a/scheduler/src/coverage/grcov.rs b/scheduler/src/coverage/grcov.rs
new file mode 100644
index 0000000..2d0c728
--- /dev/null
+++ b/scheduler/src/coverage/grcov.rs
@@ -0,0 +1,139 @@
+use std::{env, fs, io::{BufRead, BufReader}, path::{Path, PathBuf}, process::Stdio};
+
+use anyhow::{anyhow, Context, Result};
+
+#[derive(Debug, Clone)]
+pub enum GrcovBinary {
+    Grcov,
+    Gcovr
+}
+
+impl From<String> for GrcovBinary {
+    fn from(s: String) -> Self {
+        match s.as_str() {
+            "grcov" => GrcovBinary::Grcov,
+            "gcovr" => GrcovBinary::Gcovr,
+            _ => panic!("Invalid gcov reporter binary: {}", s),
+        }
+    }
+}
+
+impl Into<String> for GrcovBinary {
+    fn into(self) -> String {
+        match self {
+            GrcovBinary::Grcov => "grcov".to_string(),
+            GrcovBinary::Gcovr => "gcovr".to_string(),
+        }
+    }
+}
+
+#[derive(Debug)]
+pub struct Grcov {
+    bin_path: PathBuf,
+    binary: GrcovBinary,
+    args: Vec<String>,
+}
+
+#[derive(Debug, Default)]
+pub struct Coverage {
+    pub branches_hit: u64,
+    pub branches_total: u64,
+    pub lines_hit: u64,
+    pub lines_total: u64,
+}
+
+impl Grcov {
+    pub fn build(binary: GrcovBinary, args: Vec<String>) -> Result<Grcov> {
+        let bin: String = binary.clone().into();
+                
+        let which_output = std::process::Command::new("which")
+            .arg(&bin)
+            .output()
+            .context(format!("Failed to execute 'which {}'", bin))?;
+
+        let bin_path = if which_output.status.success() {
+            let bin_path = String::from_utf8(which_output.stdout)
+                .context(format!("Failed to parse 'which {} output", bin))?
+                .trim()
+                .to_string();
+
+            let bin_path = PathBuf::from(bin_path);
+            if !bin_path.exists() {
+                return Err(anyhow!("{} not found at the path returned by 'which'", bin));
+            }
+
+            bin_path
+        } else {
+            let home_dir = env::var_os("HOME")
+                .or_else(|| env::var_os("USERPROFILE"))
+                .map(PathBuf::from)
+                .unwrap();
+
+            let cargo_bin = home_dir.join(".cargo").join("bin").join(bin.clone());
+            if !cargo_bin.exists() {
+                return Err(anyhow!("{} not found in $HOME/.cargo/bin folder", bin));
+            }
+
+            cargo_bin
+        };
+
+        Ok(Grcov {
+            bin_path,
+            binary,
+            args,
+        })
+    }
+
+    pub fn spawn(&self) -> Result<Coverage> {
+        let output = std::process::Command::new(self.bin_path.to_str().unwrap())
+            .args(self.args.to_owned())
+            .stdout(Stdio::piped())
+            .spawn()
+            .map_err(|e| {
+                anyhow!(
+                    "Error in spawning: {:?} {:#?}, caused by: {:#?}",
+                    self.binary,
+                    self.args,
+                    e
+                )
+            })?
+            .stdout
+            .expect(format!("{:?} process returns empty", self.binary).as_str());
+
+        let mut coverage = Coverage::default();
+
+        let reader = BufReader::new(output);
+        for line in reader.lines() {
+            let line = line?;
+            let parts: Vec<&str> = line.split(':').collect();
+
+            match parts[0] {
+                "LF" => coverage.lines_total += parts[1].parse::<u64>().unwrap_or(0),
+                "LH" => coverage.lines_hit += parts[1].parse::<u64>().unwrap_or(0),
+                "BRF" => coverage.branches_total += parts[1].parse::<u64>().unwrap_or(0),
+                "BRH" => coverage.branches_hit += parts[1].parse::<u64>().unwrap_or(0),
+                _ => {} // Ignore other lines
+            }
+        }
+
+        Ok(coverage)
+    }
+}
+
+// Recursively delete all the gcda files in the src-dir
+pub fn cleanup_gcda(dir: &Path) -> std::io::Result<()> {
+    if dir.is_dir() {
+        for entry in fs::read_dir(dir)? {
+            let entry = entry?;
+            let path = entry.path();
+            if path.is_dir() {
+                cleanup_gcda(&path)?;
+            } else if let Some(extension) = path.extension() {
+                if extension == "gcda" {
+                    fs::remove_file(path)?;
+                }
+            }
+        }
+    }
+    Ok(())
+}
\ No newline at end of file
diff --git a/scheduler/src/coverage/mod.rs b/scheduler/src/coverage/mod.rs
index bdedb83..b1e3e71 100644
--- a/scheduler/src/coverage/mod.rs
+++ b/scheduler/src/coverage/mod.rs
@@ -10,6 +10,7 @@ pub mod classic;
 pub mod networked;
 pub mod sgfuzz;
 pub mod stateafl;
+pub mod grcov;
 
 mod postprocess;
 pub use postprocess::postprocess_llvm_cov;
diff --git a/scheduler/src/coverage/networked.rs b/scheduler/src/coverage/networked.rs
index 8886de7..3f51ce4 100644
--- a/scheduler/src/coverage/networked.rs
+++ b/scheduler/src/coverage/networked.rs
@@ -1,26 +1,41 @@
 use std::{
     cell::RefCell,
-    fs,
-    process::Command,
+    env,
+    ffi::{CStr, CString},
+    fs::{self, OpenOptions},
+    io::{BufRead, BufReader, Write},
+    iter::once,
+    os::fd::AsRawFd,
+    path::PathBuf,
+    process::{Command, Stdio},
+    ptr,
     sync::{
         atomic::{self, AtomicBool},
         Arc,
     },
+    thread::{self, sleep},
     time::{Duration, Instant},
 };
 
 use crate::{
     config::Config,
-    coverage::write_cov_binary_info,
+    coverage::{
+        grcov::{Grcov, GrcovBinary},
+        write_cov_binary_info,
+    },
     fuzzer::queue::{Queue, QueueEntry},
     networked::{get_consumer, get_producer, Client, Server, WaitForPeerResult},
     sink::AflSink,
     source::Source,
 };
 
+use anyhow::anyhow;
 use anyhow::Result;
+use chrono::Local;
 use fuzztruction_shared::mutation_cache::MutationCache;
 use itertools::Itertools;
+use libc::{c_char, fork};
+use nix::unistd::execve;
 
 unsafe fn load_mutations(source: &mut Source, entry: &QueueEntry) -> Result<()> {
     let mutations = entry.mutations();
@@ -39,6 +54,249 @@ unsafe fn load_mutations(source: &mut Source, entry: &QueueEntry) -> Result<()>
     Ok(())
 }
 
+pub fn compute_gcov(
+    config: &Config,
+    exit_requested: Arc<AtomicBool>,
+    timeout: Duration,
+    replay_step: u32,
+    gcov_step: u32,
+) -> Result<()> {
+    let gcov_config = config.gcov.as_ref().unwrap();
+
+    let grcov_args = match gcov_config.reporter.to_owned().into() {
+        GrcovBinary::Grcov => {
+            vec![
+                "--threads",
+                "2",
+                "-t",
+                "lcov",
+                "--branch",
+                "--ignore-not-existing",
+                "-s",
+                gcov_config.src_dir.to_str().unwrap(),
+                gcov_config.src_dir.to_str().unwrap(),
+            ]
+        }
+        GrcovBinary::Gcovr => {
+            vec!["--lcov", "-r", gcov_config.src_dir.to_str().unwrap()]
+        }
+    }
+    .into_iter()
+    .map(|s| s.into())
+    .collect();
+
+    let grcov = Grcov::build(gcov_config.reporter.to_owned().into(), grcov_args)?;
+
+    let mut cov_tmp_file = tempfile::NamedTempFile::new().unwrap();
+    log::debug!(
+        "Coverage temp file: {}",
+        cov_tmp_file.path().to_str().unwrap()
+    );
+    cov_tmp_file
+        .write_all("time,l_abs,l_per,b_abs,b_per\n".as_bytes())
+        .unwrap();
+
+    let queue_path = config.general.queue_path();
+    log::info!("Loading queue at {queue_path:?} from disk...");
+    let queue = Queue::load(&queue_path, None)?;
+    log::info!("Tracing {} queue entries", queue.len());
+
+    let mut source = Source::from_config(config, None, Some("gcov")).unwrap();
+    source.start().expect("Failed to start source");
+    let _pp = source.get_patchpoints()?;
+
+    let mock_time = Local::now();
+
+    for (idx, entry) in queue.iter().sorted_by_key(|q| q.id().0).enumerate() {
+        if idx % replay_step as usize != 0 {
+            continue;
+        }
+
+        if exit_requested.load(atomic::Ordering::SeqCst) {
+            break;
+        }
+
+        log::info!("Processing queue entry {:?}", entry.id());
+        let ts = (entry.creation_ts().unwrap() + mock_time.timestamp_millis()) / 1000;
+        unsafe {
+            load_mutations(&mut source, &entry)?;
+        }
+        source.sync_mutations()?;
+
+        let pid = unsafe { fork() };
+
+        if pid == 0 {
+            unsafe {
+                let ret = libc::setsid();
+                assert!(ret >= 0);
+            }
+
+            let dev_null_fd = unsafe {
+                let path = CString::new("/dev/null".as_bytes()).unwrap();
+                libc::open(path.as_ptr(), libc::O_RDONLY)
+            };
+            if dev_null_fd < 0 {
+                panic!("Failed to open /dev/null");
+            }
+
+            let mut sink_workdir = config.general.work_dir.to_owned();
+            sink_workdir.push("0-gcov");
+            sink_workdir.push("sink");
+            sink_workdir.push("workdir");
+
+            if !sink_workdir.exists() {
+                fs::create_dir_all(&sink_workdir).expect("Failed to create sink workdir");
+            }
+
+            if config.sink.log_stdout {
+                let mut path = sink_workdir.to_owned();
+                path.push("stdout");
+                let file = OpenOptions::new()
+                    .read(true)
+                    .write(true)
+                    .create(true)
+                    .truncate(true)
+                    .open(&path)
+                    .unwrap();
+                let fd = file.as_raw_fd();
+                unsafe {
+                    libc::dup2(fd, libc::STDOUT_FILENO);
+                    libc::close(fd);
+                }
+            } else {
+                unsafe {
+                    libc::dup2(dev_null_fd, libc::STDOUT_FILENO);
+                }
+            }
+
+            if config.sink.log_stderr {
+                let mut path = sink_workdir.to_owned();
+                path.push("stderr");
+                let file = OpenOptions::new()
+                    .read(true)
+                    .write(true)
+                    .create(true)
+                    .truncate(true)
+                    .open(&path)
+                    .unwrap();
+                let fd = file.as_raw_fd();
+                unsafe {
+                    libc::dup2(fd, libc::STDERR_FILENO);
+                    libc::close(fd);
+                }
+            } else {
+                unsafe {
+                    libc::dup2(dev_null_fd, libc::STDERR_FILENO);
+                }
+            }
+
+            // is child
+            let mut argv: Vec<CString> = config
+                .sink
+                .arguments
+                .iter()
+                .map(|arg| CString::new(arg.to_owned()).unwrap())
+                .collect();
+            let bin_path = gcov_config.bin_path.to_str().unwrap();
+            let bin = CString::new(bin_path).unwrap();
+            argv.insert(0, bin.clone());
+            println!("execve({}, {:#?})", bin_path, argv);
+
+            env::set_current_dir(config.gcov.as_ref().unwrap().src_dir.to_owned()).unwrap();
+
+            let envs: Vec<CString> = config
+                .gcov
+                .as_ref()
+                .unwrap()
+                .env
+                .iter()
+                .map(|e| CString::new(format!("{}={}", e.0, e.1)).unwrap())
+                .collect();
+            // thread::sleep(Duration::from_secs(30));
+            log::trace!("Environment variables: {:#?}", envs);
+
+            if let Err(e) = execve(&bin, &argv, &envs) {
+                log::error!("Error in execve: {:#?}", e);
+                let error = std::io::Error::last_os_error();
+                log::error!("Last OS error: {:#?}", error);
+                std::process::exit(1);
+            }
+            unreachable!("Unreachable: execve returned");
+        } else if pid > 0 {
+            // is parent
+        } else {
+            // pid < 0
+            return Err(anyhow!("Fork failed!"));
+        }
+
+        log::debug!("Target pid: {pid}");
+
+        // is parent
+        if wait_listening(
+            pid,
+            config.sink.server_port.as_ref().unwrap().parse().unwrap(),
+            true,
+            timeout,
+        )
+        .is_err()
+        {
+            // thread::sleep(Duration::from_secs(100));
+            return Err(anyhow!(
+                "Timeout in waiting for the process {} to listen on the port {}",
+                pid,
+                config.sink.server_port.as_ref().unwrap()
+            ));
+        }
+
+        source.spawn(timeout)?;
+        thread::sleep(timeout);
+        let _ = nix::sys::signal::kill(nix::unistd::Pid::from_raw(pid), nix::sys::signal::SIGTERM);
+        source.wait_for_child_termination(timeout, true)?;
+
+        if idx % gcov_step as usize != 0 {
+            continue;
+        }
+
+        let coverage = grcov.spawn()?;
+
+        // Compute line coverage ratio
+        let l_per = if coverage.lines_total > 0 {
+            (coverage.lines_hit as f64 / coverage.lines_total as f64) * 100.0
+        } else {
+            0.0
+        };
+
+        // Compute branch coverage ratio
+        let b_per = if coverage.branches_total > 0 {
+            (coverage.branches_hit as f64 / coverage.branches_total as f64) * 100.0
+        } else {
+            0.0
+        };
+
+        // Format the absolute values and percentages
+        let l_abs = coverage.lines_hit;
+        let b_abs = coverage.branches_hit;
+        let l_per = format!("{:.4}", l_per);
+        let b_per = format!("{:.4}", b_per);
+
+        cov_tmp_file
+            .write_all(format!("{ts},{l_abs},{l_per},{b_abs},{b_per}\n").as_bytes())
+            .unwrap();
+        cov_tmp_file.flush().unwrap();
+
+        log::info!("Coverage:\nLine:\t{l_abs}({l_per}%)\nBranch:\t{b_abs}({b_per}%)");
+        log::info!(
+            "Finished measuring coverage of the {idx}-th queue entry, progress: {:.2}%",
+            idx as f64 / queue.len() as f64 * 100f64
+        );
+    }
+
+    let temp_path = cov_tmp_file.into_temp_path();
+    fs::copy(&temp_path, config.general.work_dir.join("coverage.csv")).unwrap();
+
+    Ok(())
+}
+
 pub fn compute_llvm_cov(
     config: &Config,
     exit_requested: Arc<AtomicBool>,
@@ -183,3 +441,68 @@ pub fn compute_llvm_cov(
 
     Ok(())
 }
+
+pub fn wait_listening(pid: i32, port: u16, v4: bool, timeout: Duration) -> Result<()> {
+    let start = Instant::now();
+    loop {
+        if is_listening(pid, port, v4)? {
+            return Ok(());
+        }
+        log::trace!(
+            "Waiting for the process {} to listen on the port {}",
+            pid,
+            port
+        );
+        if start.elapsed() > timeout {
+            return Err(anyhow!(
+                "Timeout in waiting for the process {} to listen on the port {}",
+                pid,
+                port
+            ));
+        }
+        sleep(Duration::from_millis(100));
+    }
+}
+
+fn is_listening(pid: i32, port: u16, v4: bool) -> Result<bool> {
+    let fd_path = format!("/proc/{}/fd", pid);
+    for entry in fs::read_dir(fd_path)? {
+        let entry = entry?;
+        let path = entry.path();
+        if let Ok(target) = fs::read_link(&path) {
+            if target.to_string_lossy().starts_with("socket:[") {
+                let inode = target
+                    .to_string_lossy()
+                    .trim_start_matches("socket:[")
+                    .trim_end_matches(']')
+                    .parse::<u64>()?;
+                if grep_socket_port(inode, port, v4)? {
+                    return Ok(true);
+                }
+            }
+        }
+    }
+    Ok(false)
+}
+
+fn grep_socket_port(inode: u64, port: u16, v4: bool) -> Result<bool> {
+    let tcp_socket_path = if v4 {
+        "/proc/net/tcp"
+    } else {
+        "/proc/net/tcp6"
+    };
+    let tcp_socket_file = fs::File::open(tcp_socket_path)?;
+    for line in BufReader::new(tcp_socket_file).lines().skip(1) {
+        let line = line?;
+        let parts: Vec<&str> = line.split_whitespace().collect();
+        if parts.len() > 9 {
+            let local_address = parts[1];
+            let local_port = u16::from_str_radix(&local_address[9..], 16)?;
+            let socket_inode = parts[9].parse::<u64>()?;
+            if local_port == port && socket_inode == inode {
+                return Ok(true);
+            }
+        }
+    }
+    Ok(false)
+}
diff --git a/scheduler/src/fuzzer/common.rs b/scheduler/src/fuzzer/common.rs
index 934c860..2f6fa0f 100644
--- a/scheduler/src/fuzzer/common.rs
+++ b/scheduler/src/fuzzer/common.rs
@@ -201,9 +201,9 @@ pub fn common_calibrate(
         .unwrap_or(DEFAULT_CALIBRATION_TIMEOUT);
 
     let mut exec_durations = Vec::with_capacity(CALIBRATION_MEASURE_CYCLES.try_into().unwrap());
-    if config.sink.send_sigterm {
-        default_timeout *= 2;
-    }
+    // if config.sink.send_sigterm {
+    //     default_timeout *= 2;
+    // }
 
     let mut crash_did_not_crash_ctr = 0;
 
diff --git a/scheduler/src/fuzzer/worker_impl/init.rs b/scheduler/src/fuzzer/worker_impl/init.rs
index 728d127..a2d288b 100644
--- a/scheduler/src/fuzzer/worker_impl/init.rs
+++ b/scheduler/src/fuzzer/worker_impl/init.rs
@@ -37,15 +37,6 @@ impl FuzzingWorker {
         self.source = Some(Source::from_config(&self.config, Some(self.uid.0), None)?);
         self.sink = Some(AflSink::from_config(&self.config, Some(self.uid.0), None)?);
 
-        let ret = unsafe { libc::unshare(libc::CLONE_NEWNET) };
-        assert!(ret == 0);
-
-        let ret = process::Command::new("ip")
-            .args(["link", "set", "dev", "lo", "up"])
-            .spawn()?
-            .wait_with_output()?;
-        log::info!("ret={:?}", ret);
-
         self.source.as_mut().unwrap().start()?;
         self.sink.as_mut().unwrap().start()?;
         self.resize_bitmaps();
diff --git a/scheduler/src/sink.rs b/scheduler/src/sink.rs
index a4b0084..2cbb0e2 100644
--- a/scheduler/src/sink.rs
+++ b/scheduler/src/sink.rs
@@ -725,8 +725,8 @@ impl AflSink {
             InputChannel::Stdin => unsafe {
                 libc::dup2(self.input_file.0.as_raw_fd(), 0);
             },
-            _ => unsafe {
-                libc::dup2(*DEV_NULL_FD, STDIN_FILENO);
+            _ =>  {
+                // libc::dup2(*DEV_NULL_FD, STDIN_FILENO);
             },
         }
     }
diff --git a/scheduler/src/source.rs b/scheduler/src/source.rs
index 549ac57..d95ef13 100644
--- a/scheduler/src/source.rs
+++ b/scheduler/src/source.rs
@@ -1,6 +1,6 @@
 #![allow(clippy::type_complexity)]
 
-use byte_unit::{n_mib_bytes};
+use byte_unit::n_mib_bytes;
 use fuzztruction_shared::{
     aux_messages::{AuxStreamMessage, AuxStreamType},
     aux_stream::AuxStreamAssembler,
@@ -465,7 +465,8 @@ impl Source {
                 // This is an own mount in our mount namespace, thus we need
                 // to explicitly mount it.
                 jail.bind_rw(&workdir);
-                jail.no_random_devices();
+
+                // jail.no_random_devices();
                 Some(jail.build()?)
             } else {
                 None
@@ -740,8 +741,24 @@ impl Source {
                     assert_eq!(ret, 0);
 
                     // Disable ASLR since we rely on all instances having the same memory layout.
-                    let ret = libc::personality(libc::ADDR_NO_RANDOMIZE as u64);
-                    assert_eq!(ret, 0);
+                    let _ = libc::personality(libc::ADDR_NO_RANDOMIZE as u64);
+                    let check_personality = libc::personality(0xffffffff);
+                    if check_personality & libc::ADDR_NO_RANDOMIZE == 0 {
+                        let err = std::io::Error::last_os_error();
+                        let errno = err.raw_os_error().unwrap_or(0);
+                        match errno {
+                            libc::EINVAL => {
+                                log::error!("Invalid argument");
+                            }
+                            libc::EPERM => {
+                                log::error!("Operation not permitted");
+                            }
+                            _ => {
+                                log::error!("Unknown error: {}", errno);
+                            }
+                        }
+                        panic!("Failed to disable ASLR");
+                    }
 
                     if let Some(ref mut jail) = self.jail {
                         // ! Make sure that the code in `enter()` is async-signal-safe since we
@@ -1494,8 +1511,20 @@ impl Source {
                     } else {
                         /* Signals are represented by negative exit codes */
                         log::trace!("Child was signalled");
+                        let signal = match Signal::try_from(libc::WTERMSIG(-exit_code)) {
+                            Ok(signal) => signal,
+                            Err(err) => {
+                                log::error!(
+                                    "Failed to convert exit code to signal: {:?}, exit_code is {}",
+                                    err,
+                                    exit_code
+                                );
+                                log::error!("Use the SIGUSR1 to substitute the signal value {}, temporary workaround until we understand the signal conversion better", -exit_code);
+                                Signal::SIGUSR1
+                            }
+                        };
                         return Ok((RunResult::Signalled {
-                            signal: Signal::try_from(libc::WTERMSIG(-exit_code)).unwrap(),
+                            signal,
                             msgs: self.msg_buffer.take().unwrap(),
                         })
                         .into());
