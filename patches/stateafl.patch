diff --git a/afl-fuzz.c b/afl-fuzz.c
index 04d5fae..2e81f33 100644
--- a/afl-fuzz.c
+++ b/afl-fuzz.c
@@ -66,6 +66,7 @@
 #include <sys/mman.h>
 #include <sys/ioctl.h>
 #include <sys/file.h>
+#include <sys/personality.h>
 
 #include "aflnet.h"
 #include <graphviz/gvc.h>
@@ -110,14 +111,16 @@ EXP_ST u8 *in_dir,                    /* Input directory with test cases  */
 					 "vanilla" binary                 */
           *orig_cmdline;              /* Original command line            */
 
-EXP_ST u32 exec_tmout = EXEC_TIMEOUT; /* Configurable exec timeout (ms)   */
+EXP_ST u32 exec_tmout = EXEC_TIMEOUT, /* Configurable exec timeout (ms)   */
+           cpu_to_bind = 0;           /* id of free CPU core to bind      */
 static u32 hang_tmout = EXEC_TIMEOUT; /* Timeout used for hang det (ms)   */
 
 EXP_ST u64 mem_limit  = MEM_LIMIT;    /* Memory cap for child (MB)        */
 
 static u32 stats_update_freq = 1;     /* Stats update frequency (execs)   */
 
-EXP_ST u8  skip_deterministic,        /* Skip deterministic stages?       */
+EXP_ST u8  cpu_to_bind_given,         /* Specified cpu_to_bind given?     */
+           skip_deterministic,        /* Skip deterministic stages?       */
            force_deterministic,       /* Force deterministic stages?      */
            use_splicing,              /* Recombine input files?           */
            dumb_mode,                 /* Run in non-instrumented mode?    */
@@ -1724,6 +1727,15 @@ static void bind_to_free_cpu(void) {
 
   }
 
+if (getenv("PFB_CPU_CORE")) {
+int i=atoi(getenv("PFB_CPU_CORE"));
+cpu_aff = i;
+CPU_ZERO(&c);
+CPU_SET(i, &c);
+if (sched_setaffinity(0, sizeof(c), &c)) PFATAL("sched_setaffinity failed");
+return;
+}
+
   d = opendir("/proc");
 
   if (!d) {
@@ -1788,7 +1800,20 @@ static void bind_to_free_cpu(void) {
 
   closedir(d);
 
-  for (i = 0; i < cpu_core_count; i++) if (!cpu_used[i]) break;
+  if (cpu_to_bind_given) {
+
+    if (cpu_to_bind >= cpu_core_count)
+      FATAL("The CPU core id to bind should be between 0 and %u", cpu_core_count - 1);
+    
+    if (cpu_used[cpu_to_bind])
+      FATAL("The CPU core #%u to bind is not free!", cpu_to_bind);
+
+    i = cpu_to_bind;
+    
+  } else {
+    for (i = 0; i < cpu_core_count; i++) if (!cpu_used[i]) break;
+  }
+  
 
   if (i == cpu_core_count) {
 
@@ -4807,7 +4832,7 @@ static void pivot_inputs(void) {
       u8* use_name = strstr(rsl, ",orig:");
 
       if (use_name) use_name += 6; else use_name = rsl;
-      nfn = alloc_printf("%s/queue/id:%06u,orig:%s", out_dir, id, use_name);
+      nfn = alloc_printf("%s/queue/id:%06u,ts:%lld,orig:%s", out_dir, id, get_cur_time() - start_time, use_name);
 
 #else
 
@@ -4953,8 +4978,8 @@ static u8 save_if_interesting(char** argv, void* mem, u32 len, u8 fault) {
 
 #ifndef SIMPLE_FILES
 
-    fn = alloc_printf("%s/queue/id:%06u,%s", out_dir, queued_paths,
-                      describe_op(hnb));
+    fn = alloc_printf("%s/queue/id:%06u,ts:%lld,%s", out_dir, queued_paths,
+                      get_cur_time() - start_time, describe_op(hnb));
 
 #else
 
@@ -5051,8 +5076,8 @@ static u8 save_if_interesting(char** argv, void* mem, u32 len, u8 fault) {
 
 #ifndef SIMPLE_FILES
 
-      fn = alloc_printf("%s/replayable-hangs/id:%06llu,%s", out_dir,
-                        unique_hangs, describe_op(0));
+      fn = alloc_printf("%s/replayable-hangs/id:%06llu,ts:%lld,%s", out_dir,
+                        unique_hangs, get_cur_time() - start_time, describe_op(0));
 
 #else
 
@@ -5095,8 +5120,8 @@ keep_as_crash:
 
 #ifndef SIMPLE_FILES
 
-      fn = alloc_printf("%s/replayable-crashes/id:%06llu,sig:%02u,%s", out_dir,
-                        unique_crashes, kill_signal, describe_op(0));
+      fn = alloc_printf("%s/replayable-crashes/id:%06llu,ts:%lld,sig:%02u,%s", out_dir,
+                        unique_crashes, get_cur_time() - start_time, kill_signal, describe_op(0));
 
 #else
 
@@ -8907,6 +8932,8 @@ static void sync_fuzzers(char** argv) {
   struct dirent* sd_ent;
   u32 sync_cnt = 0;
 
+  return;
+
   sd = opendir(sync_dir);
   if (!sd) PFATAL("Unable to open '%s'", sync_dir);
 
@@ -9845,8 +9872,8 @@ static void check_asan_opts(void) {
     if (!strstr(x, "abort_on_error=1"))
       FATAL("Custom ASAN_OPTIONS set without abort_on_error=1 - please fix!");
 
-    if (!strstr(x, "symbolize=0"))
-      FATAL("Custom ASAN_OPTIONS set without symbolize=0 - please fix!");
+    // if (!strstr(x, "symbolize=0"))
+    //   FATAL("Custom ASAN_OPTIONS set without symbolize=0 - please fix!");
 
   }
 
@@ -10083,7 +10110,19 @@ int main(int argc, char** argv) {
   gettimeofday(&tv, &tz);
   srandom(tv.tv_sec ^ tv.tv_usec ^ getpid());
 
-  while ((opt = getopt(argc, argv, "+i:o:f:m:t:T:dnCB:S:M:x:QN:D:W:r:w:e:P:KEq:s:RFc:l:u:U:")) > 0)
+  unsigned long persona = personality(0xffffffff);
+    if (persona == -1) {
+        perror("Failed to get personality");
+        return 1;
+    }
+
+    if (personality(persona | ADDR_NO_RANDOMIZE) == -1) {
+        perror("Failed to set personality");
+        return 1;
+    }
+    printf("ASLR disabled for this process\n");
+
+  while ((opt = getopt(argc, argv, "+i:b:o:f:m:t:T:dnCB:S:M:x:QN:D:W:r:w:e:P:KEq:s:RFc:l:u:U:")) > 0)
 
     switch (opt) {
 
@@ -10204,6 +10243,16 @@ int main(int argc, char** argv) {
         use_splicing = 1;
         break;
 
+      case 'b':  /* bind CPU core */
+
+          if (cpu_to_bind_given) FATAL("Multiple -b options not supported");
+          cpu_to_bind_given = 1;
+
+          if (sscanf(optarg, "%u", &cpu_to_bind) < 1 ||
+              optarg[0] == '-') FATAL("Bad syntax used for -b");
+
+          break;
+
       case 'B': /* load bitmap */
 
         /* This is a secret undocumented option! It is useful if you find
@@ -10420,6 +10469,7 @@ int main(int argc, char** argv) {
 
   //if (!protocol_selected) FATAL("Please specify the protocol to be tested using the -P option");
 
+  start_time = get_cur_time();
   setup_signal_handlers();
   check_asan_opts();
 
@@ -10470,7 +10520,7 @@ int main(int argc, char** argv) {
 #endif /* HAVE_AFFINITY */
 
   check_crash_handling();
-  check_aslr();
+  //check_aslr();
   check_cpu_governor();
 
   setup_post();
@@ -10495,8 +10545,6 @@ int main(int argc, char** argv) {
 
   check_binary(argv[optind]);
 
-  start_time = get_cur_time();
-
   if (qemu_mode)
     use_argv = get_qemu_argv(argv[0], argv + optind, argc - optind);
   else
diff --git a/aflnet.c b/aflnet.c
index 3df6638..5de7270 100644
--- a/aflnet.c
+++ b/aflnet.c
@@ -13,6 +13,125 @@
 
 // Protocol-specific functions for extracting requests and responses
 
+unsigned int* extract_response_codes_mqtt(unsigned char* buf, unsigned int buf_size, unsigned int* state_count_ref)
+{
+  unsigned char *mem;
+	unsigned int byte_count = 0;
+	unsigned int mem_count = 0;
+	unsigned int mem_size = 1024;
+	unsigned int *state_sequence = NULL;
+	unsigned int state_count = 0;
+  // Packet headers for MQTT broker responses
+	char start1[1]={0x20}; // Connect Ack
+	char start2[1]={0x40}; // Publish Ack
+  char start3[1]={0x50}; // Publish Receive
+  char start4[1]={0x62}; // Publish Release
+  char start5[1]={0x70}; // Publish complete
+	char start6[1]={0x90}; // Subscribe Ack
+  char start7[1]={0xB0}; // Unsubscribe Ack
+  char start8[1]={0xD0}; // Ping Response
+  char start9[1]={0xE0}; // Disconnect
+  char start10[1]={0xF0}; // Auth
+	mem=(unsigned char *)ck_alloc(mem_size);
+	// Initial state of the response state machine
+	state_count++;
+	state_sequence = (unsigned int *)ck_realloc(state_sequence, state_count * sizeof(unsigned int));
+	state_sequence[state_count - 1] = 0;
+  while(byte_count < buf_size)
+  {
+    // Copy the packet header to get the message type(mem[0])
+		memcpy(&mem[mem_count++], buf + byte_count++, 1);
+		memcpy(&mem[mem_count], buf + byte_count++, 1);
+    // printf("[fuzz]mem[0] is %02x\n",mem[0]);
+    // printf("[fuzz]mem[1] is %02x\n",mem[1]);
+    // Determine whether it's a response packet
+    if ((mem_count > 0) && ((memcmp(&mem[0], start1, 1) == 0) || (memcmp(&mem[0], start2, 1) == 0) || (memcmp(&mem[0], start3, 1) == 0) || (memcmp(&mem[0], start4, 1) == 0) || (memcmp(&mem[0], start5, 1) == 0) || (memcmp(&mem[0], start6, 1) == 0) || (memcmp(&mem[0], start7, 1) == 0) || (memcmp(&mem[0], start8, 1) == 0) || (memcmp(&mem[0], start9, 1) == 0) || (memcmp(&mem[0], start10, 1) == 0)))
+    {
+      // Get the response code(message type) from the packet
+      unsigned char message_code = (unsigned char)mem[0];
+      // printf("[fuzz]message_code is %02x\n",message_code);
+			if (message_code == 0) break;
+      // Create a new state 
+			state_count++;
+			state_sequence = (unsigned int *)ck_realloc(state_sequence, state_count * sizeof(unsigned int));
+			state_sequence[state_count - 1] = message_code;
+			mem_count = 0;
+      // yk
+			byte_count = byte_count + mem[1];
+    }
+    else
+    {
+      mem_count++;
+      if(mem_count == mem_size)
+      {
+        //enlarge the mem buffer
+        mem_size = mem_size * 2;
+        mem=(char *)ck_realloc(mem, mem_size); 
+      }
+    }
+  }
+	if (mem) ck_free(mem);
+	*state_count_ref = state_count;
+	return state_sequence;
+}
+
+region_t* extract_requests_mqtt(unsigned char* buf, unsigned int buf_size, unsigned int* region_count_ref)
+{
+  char *mem;
+  unsigned int mem_count = 0;
+  unsigned int mem_size = 1024;
+  unsigned int region_count = 0;
+  unsigned int cur_start = 0;
+  unsigned int cur_end = 0;
+  region_t *regions = NULL;
+  mem=(char *)ck_alloc(mem_size);
+  while(cur_start < buf_size)
+  {
+		if ((buf_size - cur_start) == 1) {
+			region_count++;
+			regions = (region_t *)ck_realloc(regions, region_count * sizeof(region_t));
+			regions[region_count - 1].start_byte = cur_start;
+			regions[region_count - 1].end_byte = buf_size - 1;
+			regions[region_count - 1].state_sequence = NULL;
+			regions[region_count - 1].state_count = 0;
+			break;
+		}
+    // Read the packet header
+    memcpy(&mem[mem_count], buf + cur_start, 2);
+    cur_start = cur_start + 2;
+    // Check the packet length and update current_end
+    // mem[0] is Message Type. mem[1] is Msg Len.
+    if(mem[1] >= 0)
+      cur_end = cur_start + mem[1] - 1;
+    else
+      cur_end = buf_size;
+    // Create a region for every request
+		region_count++;
+		regions = (region_t *)ck_realloc(regions, region_count * sizeof(region_t));
+		regions[region_count - 1].start_byte = cur_start - 2;
+		regions[region_count - 1].end_byte = cur_end;
+		regions[region_count - 1].state_sequence = NULL;
+		regions[region_count - 1].state_count = 0;
+    // Update the indices
+    mem_count = 0;
+    cur_start = cur_end + 1;
+    cur_end = cur_start;
+  }
+  if(mem) ck_free(mem);
+  //in case region_count equals zero, it means that the structure of the buffer is broken
+  //hence we create one region for the whole buffer
+	if ((region_count == 0) && (buf_size > 0)) {
+		regions = (region_t *)ck_realloc(regions, sizeof(region_t));
+		regions[0].start_byte = 0;
+		regions[0].end_byte = buf_size - 1;
+		regions[0].state_sequence = NULL;
+		regions[0].state_count = 0;
+		region_count = 1;
+	}
+	*region_count_ref = region_count;
+	return regions;
+}
+
 region_t* extract_requests_smtp(unsigned char* buf, unsigned int buf_size, unsigned int* region_count_ref)
 {
    char *mem;
diff --git a/aflnet.h b/aflnet.h
index 99ccf0f..6179a85 100644
--- a/aflnet.h
+++ b/aflnet.h
@@ -57,7 +57,7 @@ KHASH_INIT(hms, khint32_t, state_info_t *, 1, kh_int_hash_func, kh_int_hash_equa
 
 /*To add support for a new application protocol, please add corresponding function declartion and implementation
 And update the code to handle -P option in the main function in afl-fuzz.c accordingly */
-
+unsigned int* extract_response_codes_mqtt(unsigned char* buf, unsigned int buf_size, unsigned int* state_count_ref);
 unsigned int* extract_response_codes_smtp(unsigned char* buf, unsigned int buf_size, unsigned int* state_count_ref);
 unsigned int* extract_response_codes_ssh(unsigned char* buf, unsigned int buf_size, unsigned int* state_count_ref);
 unsigned int* extract_response_codes_tls(unsigned char* buf, unsigned int buf_size, unsigned int* state_count_ref);
@@ -71,6 +71,7 @@ unsigned int* extract_response_codes_http(unsigned char* buf, unsigned int buf_s
 unsigned int* extract_response_codes_ipp(unsigned char* buf, unsigned int buf_size, unsigned int* state_count_ref);
 extern unsigned int* (*extract_response_codes)(unsigned char* buf, unsigned int buf_size, unsigned int* state_count_ref);
 
+region_t* extract_requests_mqtt(unsigned char* buf, unsigned int buf_size, unsigned int* region_count_ref);
 region_t* extract_requests_smtp(unsigned char* buf, unsigned int buf_size, unsigned int* region_count_ref);
 region_t* extract_requests_ssh(unsigned char* buf, unsigned int buf_size, unsigned int* region_count_ref);
 region_t* extract_requests_tls(unsigned char* buf, unsigned int buf_size, unsigned int* region_count_ref);
diff --git a/convert-pcap-replay-format.py b/convert-pcap-replay-format.py
index 2e7968c..03aea53 100755
--- a/convert-pcap-replay-format.py
+++ b/convert-pcap-replay-format.py
@@ -59,10 +59,14 @@ total_messages = 0
 request_msg = bytearray()
 ports = {}
 
+first_seen_src_port = None
+
 try:
     with open(OUTPUT,"wb") as output:
-
-        for pkt in cap:
+        packages = list(cap)
+        if packages:
+            last_pkt = packages[-1]
+        for pkt in packages:
 
             if 'TCP' or 'UDP' in pkt:
 
@@ -85,13 +89,18 @@ try:
                     print("Error: Multiple client/server flows detected")
                     print("Please check that the PCAP file only contains traffic for only one client")
                     sys.exit(1)
+                elif first_seen_src_port is not None and first_seen_src_port != srcport:
+                    print(f"src port {srcport} is different from the first seen flow's port {first_seen_src_port}, skipping")
+                    continue
 
                 if (dstport == SERVER_PORT and
                    (CLIENT_PORT is None or srcport == CLIENT_PORT)):
                     if hasattr(pkt, 'data'):
+                        if first_seen_src_port is None:
+                            first_seen_src_port = srcport
                         request_msg.extend(pkt.data.data.binary_value)
 
-                if (('TCP' in pkt and dstport != SERVER_PORT) or
+                if last_pkt is pkt or (('TCP' in pkt and dstport != SERVER_PORT) or
                    ('UDP' in pkt)) and len(request_msg) > 0:
 
                     print(f'Writing {len(request_msg)} bytes...')
@@ -111,4 +120,3 @@ if total_messages == 0:
     sys.exit(1)
 
 print(f"Converted PCAP saved to {OUTPUT}")
-
diff --git a/llvm_mode/Makefile b/llvm_mode/Makefile
index 02512e2..904cc55 100644
--- a/llvm_mode/Makefile
+++ b/llvm_mode/Makefile
@@ -37,8 +37,8 @@ CXXFLAGS    += -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign \
                -DVERSION=\"$(VERSION)\" -Wno-variadic-macros
 
 # Mark nodelete to work around unload bug in upstream LLVM 5.0+
-CLANG_CFL    = `$(LLVM_CONFIG) --cxxflags` -Wl,-znodelete -fno-rtti -fpic $(CXXFLAGS)
-CLANG_LFL    = `$(LLVM_CONFIG) --ldflags` $(LDFLAGS)
+CLANG_CFL    = `$(LLVM_CONFIG) --cxxflags` -Wl,-znodelete -fno-rtti -fpic #$(CXXFLAGS)
+CLANG_LFL    = `$(LLVM_CONFIG) --ldflags` #$(LDFLAGS)
 
 # User teor2345 reports that this is required to make things work on MacOS X.
 
@@ -90,19 +90,21 @@ endif
 
 $(CONTAINERS):
 	cd Containers && \
-	make static_clang && \
+	CFLAGS="-fsanitize=address -O0 -g" make -j1 static_clang && \
 	cp containers.a ..
 
 $(MVPTREE):
 	cd mvptree && \
-	make && \
+	make clean && \
+	CFLAGS="-fsanitize=address -O0 -g" make -j1 && \
 	cp libmvptree.a ..
 
 $(TLSH):
 	cd tlsh && \
+	rm -rf build && \
 	mkdir -p build && \
-	cd build && \
-	cmake .. && \
+	cd  build && \
+	CFLAGS="-fsanitize=address -O0 -g -fPIC" CXXFLAGS="-O0 -g -fPIC" cmake .. && \
 	make && \
 	cp ../lib/libtlsh.a ../..
 
diff --git a/llvm_mode/afl-clang-fast.c b/llvm_mode/afl-clang-fast.c
index 4104ee1..7e43a54 100644
--- a/llvm_mode/afl-clang-fast.c
+++ b/llvm_mode/afl-clang-fast.c
@@ -130,11 +130,13 @@ static void edit_params(u32 argc, char** argv) {
   cc_params[cc_par_cnt++] = "-fsanitize-coverage=trace-pc-guard";
   cc_params[cc_par_cnt++] = "-mllvm";
   cc_params[cc_par_cnt++] = "-sanitizer-coverage-block-threshold=0";
+  #error XXX
 #else
-  cc_params[cc_par_cnt++] = "-Xclang";
-  cc_params[cc_par_cnt++] = "-load";
-  cc_params[cc_par_cnt++] = "-Xclang";
-  cc_params[cc_par_cnt++] = alloc_printf("%s/afl-llvm-pass.so", obj_path);
+  // cc_params[cc_par_cnt++] = "-Xclang";
+  // cc_params[cc_par_cnt++] = "-load";
+  // cc_params[cc_par_cnt++] = "-Xclang";
+  // cc_params[cc_par_cnt++] = alloc_printf("%s/afl-llvm-pass.so", obj_path);
+  cc_params[cc_par_cnt++]  = alloc_printf("-fpass-plugin=%s/afl-llvm-pass.so", obj_path);
 #endif /* ^USE_TRACE_PC */
 
   cc_params[cc_par_cnt++] = "-Qunused-arguments";
@@ -163,7 +165,8 @@ static void edit_params(u32 argc, char** argv) {
     if (!strcmp(cur, "-shared")) maybe_linking = 0;
 
     if (!strcmp(cur, "-Wl,-z,defs") ||
-        !strcmp(cur, "-Wl,--no-undefined")) continue;
+        !strcmp(cur, "-Wl,--no-undefined") ||
+        !strcmp(cur, "-Wl,-no-undefined")) continue;
 
     cc_params[cc_par_cnt++] = cur;
 
diff --git a/llvm_mode/afl-llvm-pass.so.cc b/llvm_mode/afl-llvm-pass.so.cc
index e3d7878..a4129f2 100644
--- a/llvm_mode/afl-llvm-pass.so.cc
+++ b/llvm_mode/afl-llvm-pass.so.cc
@@ -29,6 +29,11 @@
    in ../afl-as.h.
 */
 
+#include <cassert>
+#include <cstdlib>
+#include <llvm/IR/DerivedTypes.h>
+#include <llvm/IR/Type.h>
+#include <llvm/Support/Casting.h>
 #define AFL_LLVM_PASS
 
 #include "../config.h"
@@ -37,6 +42,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
+#include <map>
 
 #include "llvm/ADT/Statistic.h"
 #include "llvm/ADT/SmallSet.h"
@@ -44,7 +50,6 @@
 #include "llvm/IR/LegacyPassManager.h"
 #include "llvm/IR/Module.h"
 #include "llvm/Support/Debug.h"
-#include "llvm/Transforms/IPO/PassManagerBuilder.h"
 
 #include "llvm/IR/DebugLoc.h"
 #include "llvm/IR/DebugInfoMetadata.h"
@@ -52,22 +57,27 @@
 
 #include "llvm/IR/DataLayout.h"
 
+#include "llvm/Passes/PassPlugin.h"
+#include "llvm/Passes/PassBuilder.h"
+#include "llvm/IR/PassManager.h"
+
 #include <cxxabi.h>
 
 #include "state-tracer.h"
 
+constexpr std::nullopt_t None = std::nullopt;
+
 using namespace llvm;
 
 namespace {
 
-  class AFLCoverage : public ModulePass {
+  class AFLCoverage : public PassInfoMixin<AFLCoverage> {
 
     public:
 
-      static char ID;
-      AFLCoverage() : ModulePass(ID) { }
+      AFLCoverage() { }
 
-      bool runOnModule(Module &M) override;
+      PreservedAnalyses run(Module &M, ModuleAnalysisManager &MAM);
 
       // StringRef getPassName() const override {
       //  return "American Fuzzy Lop Instrumentation";
@@ -78,10 +88,7 @@ namespace {
 }
 
 
-char AFLCoverage::ID = 0;
-
-
-bool AFLCoverage::runOnModule(Module &M) {
+PreservedAnalyses AFLCoverage::run(Module &M, ModuleAnalysisManager &MAM) {
 
   LLVMContext &C = M.getContext();
 
@@ -217,21 +224,20 @@ bool AFLCoverage::runOnModule(Module &M) {
       ConstantInt *CurLoc = ConstantInt::get(Int32Ty, cur_loc);
 
       /* Load prev_loc */
-
-      LoadInst *PrevLoc = IRB.CreateLoad(AFLPrevLoc);
+      LoadInst *PrevLoc = IRB.CreateLoad(IRB.getInt32Ty(), AFLPrevLoc);
       PrevLoc->setMetadata(M.getMDKindID("nosanitize"), MDNode::get(C, None));
       Value *PrevLocCasted = IRB.CreateZExt(PrevLoc, IRB.getInt32Ty());
 
       /* Load SHM pointer */
 
-      LoadInst *MapPtr = IRB.CreateLoad(AFLMapPtr);
+      LoadInst *MapPtr = IRB.CreateLoad(PointerType::get(Int8Ty, 0), AFLMapPtr);
       MapPtr->setMetadata(M.getMDKindID("nosanitize"), MDNode::get(C, None));
       Value *MapPtrIdx =
-          IRB.CreateGEP(MapPtr, IRB.CreateXor(PrevLocCasted, CurLoc));
+          IRB.CreateGEP(Int8Ty, MapPtr, IRB.CreateXor(PrevLocCasted, CurLoc));
 
       /* Update bitmap */
 
-      LoadInst *Counter = IRB.CreateLoad(MapPtrIdx);
+      LoadInst *Counter = IRB.CreateLoad(Int8Ty, MapPtrIdx);
       Counter->setMetadata(M.getMDKindID("nosanitize"), MDNode::get(C, None));
       Value *Incr = IRB.CreateAdd(Counter, ConstantInt::get(Int8Ty, 1));
       IRB.CreateStore(Incr, MapPtrIdx)
@@ -288,8 +294,7 @@ bool AFLCoverage::runOnModule(Module &M) {
 
           stack_lookups.push_back(call_instr);
         }
-        else
-        if ( called_func->getName() == "malloc" || demangled.find("operator new") != std::string::npos ) {
+        else if ( called_func->getName() == "malloc" || demangled.find("operator new") != std::string::npos ) {
           OKF("Found function call: %s\n", called_func->getName().data());
 
           if(demangled_status==0)
@@ -298,13 +303,16 @@ bool AFLCoverage::runOnModule(Module &M) {
           auto * voidTy = Type::getVoidTy(M.getContext());
           auto * int8PtrTy = Type::getInt8PtrTy(M.getContext());
           auto * int32Ty = Type::getInt32Ty(M.getContext());
+          auto * int64Ty = Type::getInt64Ty(M.getContext());
 
-          auto * helperTy = FunctionType::get(voidTy, int8PtrTy, int32Ty);
+          auto * helperTy = FunctionType::get(voidTy, int8PtrTy, int64Ty);
           auto helper_malloc = M.getOrInsertFunction("new_heap_alloc_record", helperTy);
 
           IRBuilder<> builder(call_instr);
           builder.SetInsertPoint(call_instr->getNextNode());
-          builder.CreateCall(helper_malloc, {call_instr, call_instr->getOperand(0)});
+
+          auto *size = builder.CreateIntCast(call_instr->getOperand(0), int64Ty, false);
+          builder.CreateCall(helper_malloc, {call_instr, size});
 
         }
         if ( called_func->getName() == "calloc" ) {
@@ -319,7 +327,10 @@ bool AFLCoverage::runOnModule(Module &M) {
 
           IRBuilder<> builder(call_instr);
           builder.SetInsertPoint(call_instr->getNextNode());
-          builder.CreateCall(helper_malloc, {call_instr, call_instr->getOperand(1), call_instr->getOperand(0)});
+
+          auto *num = builder.CreateIntCast(call_instr->getOperand(0), int32Ty, false);
+          auto *size = builder.CreateIntCast(call_instr->getOperand(1), int32Ty, false);
+          builder.CreateCall(helper_malloc, {call_instr, size, num});
 
         }
         if ( called_func->getName() == "realloc" ) {
@@ -334,7 +345,9 @@ bool AFLCoverage::runOnModule(Module &M) {
 
           IRBuilder<> builder(call_instr);
           builder.SetInsertPoint(call_instr->getNextNode());
-          builder.CreateCall(helper_malloc, {call_instr, call_instr->getOperand(1), call_instr->getOperand(0)});
+
+          auto *size = builder.CreateIntCast(call_instr->getOperand(1), int32Ty, false);
+          builder.CreateCall(helper_malloc, {call_instr, size, call_instr->getOperand(0)});
 
         }
         else if ( called_func->getName() == "free" || demangled.find("operator delete") != std::string::npos ) {
@@ -366,7 +379,9 @@ bool AFLCoverage::runOnModule(Module &M) {
           auto helper = M.getOrInsertFunction("trace_receive", helperTy);
 
           IRBuilder<> builder(call_instr);
-          builder.CreateCall(helper, {call_instr->getOperand(1), call_instr->getOperand(2)});
+
+          auto *size = builder.CreateIntCast(call_instr->getOperand(2), int32Ty, false);
+          builder.CreateCall(helper, {call_instr->getOperand(1), size});
 
         }
         else if( called_func->getName() == "recvmsg" )
@@ -380,26 +395,37 @@ bool AFLCoverage::runOnModule(Module &M) {
           auto * helperTy = FunctionType::get(voidTy, int8PtrTy, int32Ty);
           auto helper = M.getOrInsertFunction("trace_receive", helperTy);
 
-          Value * buf_size;
-          int struct_size;
-          Type * T = call_instr->getOperand(1)->getType();
+          // Value * buf_size;
+          // int struct_size;
+          // Type * T = call_instr->getOperand(1)->getType();
 
-          if( !T->isPointerTy() || !T->getContainedType(0)->isStructTy() ) {
+          // call_instr->dump();
+          // T->dump();
 
-            WARNF("Error in recvmsg(): non-pointer input parameter\n");
-            continue;
-          }
+          // if( !T->isPointerTy() || !T->getContainedType(0)->isStructTy() ) {
 
-          Type * PT = T->getContainedType(0);
-          llvm::DataLayout* dl = new llvm::DataLayout(&M);
-          struct_size = dl->getTypeAllocSize(PT);
+          //   WARNF("Error in recvmsg(): non-pointer input parameter\n");
+          //   continue;
+          // }
+
+          // Type * PT = T->getContainedType(0);
+          // llvm::DataLayout* dl = new llvm::DataLayout(&M);
+          // struct_size = dl->getTypeAllocSize(PT);
 
           //WARNF("Type %s size: %d\n", PT->getStructName().data(), struct_size);
 
-          buf_size = llvm::ConstantInt::get(int32Ty, struct_size, true);
+          // struct size
+          // #include <stdio.h>
+          // #include <sys/types.h>
+          // #include <sys/socket.h>
+
+          // int main() {
+          //         printf("%u", sizeof(struct msghdr));
+          // }
+          Value * msg_hdr_struct_size = llvm::ConstantInt::get(int32Ty, 56, true);
 
           IRBuilder<> builder(call_instr);
-          builder.CreateCall(helper, {call_instr->getOperand(1), buf_size});
+          builder.CreateCall(helper, {call_instr->getOperand(1), msg_hdr_struct_size});
 
         }
         else if(  called_func->getName() == "send" 
@@ -415,7 +441,9 @@ bool AFLCoverage::runOnModule(Module &M) {
           auto helper = M.getOrInsertFunction("trace_send", helperTy);
 
           IRBuilder<> builder(call_instr);
-          builder.CreateCall(helper, {call_instr->getOperand(1), call_instr->getOperand(2)});
+
+          auto *size = builder.CreateIntCast(call_instr->getOperand(2), int32Ty, false);
+          builder.CreateCall(helper, {call_instr->getOperand(1), size});
 
         }
         else if(  called_func->getName() == "sendmsg" )
@@ -429,32 +457,43 @@ bool AFLCoverage::runOnModule(Module &M) {
           auto * helperTy = FunctionType::get(voidTy, int8PtrTy, int32Ty);
           auto helper = M.getOrInsertFunction("trace_send", helperTy);
 
-          Value * buf_size;
-          int struct_size;
-          Type * T = call_instr->getOperand(1)->getType();
+          //Value * buf_size;
+          //int struct_size;
+          //Type * T = call_instr->getOperand(1)->getType();
+          // call_instr->dump();
+          // T->dump();
 
-          if( !T->isPointerTy() || !T->getContainedType(0)->isStructTy() ) {
+          // if( !T->isPointerTy() || !T->getContainedType(0)->isStructTy() ) {
 
-            WARNF("Error in sendmsg(): non-pointer input parameter\n");
-            continue;
-          }
+          //   WARNF("Error in sendmsg(): non-pointer input parameter\n");
+          //   continue;
+          // }
 
-          Type * PT = T->getContainedType(0);
-          llvm::DataLayout* dl = new llvm::DataLayout(&M);
-          struct_size = dl->getTypeAllocSize(PT);
+          // Type * PT = T->getContainedType(0);
+          // llvm::DataLayout* dl = new llvm::DataLayout(&M);
+          // struct_size = dl->getTypeAllocSize(PT);
 
-          //WARNF("Type %s size: %d\n", PT->getStructName().data(), struct_size);
+          // //WARNF("Type %s size: %d\n", PT->getStructName().data(), struct_size);
+
+          // struct size
+          // #include <stdio.h>
+          // #include <sys/types.h>
+          // #include <sys/socket.h>
 
-          buf_size = llvm::ConstantInt::get(int32Ty, struct_size, true);
+          // int main() {
+          //         printf("%u", sizeof(struct msghdr));
+          // }
+          Value * msg_hdr_struct_size = llvm::ConstantInt::get(int32Ty, 56, true);
 
           IRBuilder<> builder(call_instr);
-          builder.CreateCall(helper, {call_instr->getOperand(1), buf_size});
+          builder.CreateCall(helper, {call_instr->getOperand(1), msg_hdr_struct_size});
 
         }
-        else if(   map_custom_receive.count(called_func->getName().data()) 
+        else if(   map_custom_receive.count(called_func->getName().data())
                 || map_custom_send.count(called_func->getName()) )
         {
           OKF("Found function call: %s\n", called_func->getName().data());
+          assert(false && "Unsupported");
 
           auto * voidTy = Type::getVoidTy(M.getContext());
           auto * int8PtrTy = Type::getInt8PtrTy(M.getContext()); /* pass buffer address */
@@ -490,13 +529,13 @@ bool AFLCoverage::runOnModule(Module &M) {
 
           if(param_pos != -1) {
 
-			auto arg = called_func->arg_begin();
-			int arg_no = 0;
+            auto arg = called_func->arg_begin();
+            int arg_no = 0;
 
-			while(arg != called_func->arg_end() && arg_no < param_pos) {
-			  arg++;
-			  arg_no++;
-			}
+            while(arg != called_func->arg_end() && arg_no < param_pos) {
+              arg++;
+              arg_no++;
+            }
 
 
             Type * T = arg->getType();
@@ -554,11 +593,26 @@ bool AFLCoverage::runOnModule(Module &M) {
           auto helper_read = M.getOrInsertFunction("trace_read", helperTy);
 
           /* Note: Operand 2 (size_t) is 64 bit wide */
-          std::vector<Value *> call_args = {call_instr->getOperand(0), call_instr->getOperand(1), call_instr->getOperand(2)};
-          
+
           IRBuilder<> builder(call_instr);
+          auto *len = builder.CreateIntCast(call_instr->getOperand(2), int32Ty, false);
+          std::vector<Value *> call_args = {call_instr->getOperand(0), call_instr->getOperand(1), len};
+
           builder.CreateCall(helper_read, call_args);
+        }
+        else if( called_func->getName() == "readv" ) {
+          OKF("Found function call: %s\n", called_func->getName().data());
+
+          auto * voidTy = Type::getVoidTy(M.getContext());
+          auto * int32Ty = Type::getInt32Ty(M.getContext());
+          auto * int8PtrTy = Type::getInt8PtrTy(M.getContext()); /* pass buffer address */
+
+          auto * helperTy = FunctionType::get(voidTy, {int32Ty, int8PtrTy, int32Ty}, false);
+          auto helper_read = M.getOrInsertFunction("trace_readv", helperTy);
 
+          IRBuilder<> builder(call_instr);
+          std::vector<Value *> call_args = {call_instr->getOperand(0), call_instr->getOperand(1), call_instr->getOperand(2)};
+          builder.CreateCall(helper_read, call_args);
         }
         else if( called_func->getName() == "write" ) {
           OKF("Found function call: %s\n", called_func->getName().data());
@@ -570,14 +624,38 @@ bool AFLCoverage::runOnModule(Module &M) {
           auto * helperTy = FunctionType::get(voidTy, {int32Ty, int8PtrTy, int32Ty}, false);
           auto helper_write = M.getOrInsertFunction("trace_write", helperTy);
 
-          std::vector<Value *> call_args = {call_instr->getOperand(0), call_instr->getOperand(1), call_instr->getOperand(2)};
 
           IRBuilder<> builder(call_instr);
+          auto *size = builder.CreateIntCast(call_instr->getOperand(2), int32Ty, false);
+          std::vector<Value *> call_args = {call_instr->getOperand(0), call_instr->getOperand(1), size};
+
           builder.CreateCall(helper_write, call_args);
+        }
+        else if( called_func->getName() == "writev" ) {
+          if (getenv("FT_SKIP_WRITEV")) {
+            continue;
+          }
+          OKF("Found function call: %s\n", called_func->getName().data());
+
+          auto * voidTy = Type::getVoidTy(M.getContext());
+          auto * int32Ty = Type::getInt32Ty(M.getContext());
+          auto * int8PtrTy = Type::getInt8PtrTy(M.getContext()); /* pass buffer address */
+
+          auto * helperTy = FunctionType::get(voidTy, {int32Ty, int8PtrTy, int32Ty}, false);
+          auto helper_write = M.getOrInsertFunction("trace_writev", helperTy);
+
+          IRBuilder<> builder(call_instr);
+          std::vector<Value *> call_args = {call_instr->getOperand(0), call_instr->getOperand(1), call_instr->getOperand(2)};
 
+          builder.CreateCall(helper_write, call_args);
         }
         else if( called_func->getName() == "fprintf" ) {
           OKF("Found function call: %s\n", called_func->getName().data());
+#if 1
+          // taking the return value of fprintf and using this as bound for the format
+          // string buffer does not make any sense.
+          continue;
+#endif
 
           auto * voidTy = Type::getVoidTy(M.getContext());
           auto * int8PtrTy = Type::getInt8PtrTy(M.getContext());
@@ -586,10 +664,12 @@ bool AFLCoverage::runOnModule(Module &M) {
           auto * helperTy = FunctionType::get(voidTy, { int8PtrTy, int8PtrTy, int32Ty }, false);
           auto helper = M.getOrInsertFunction("trace_fprintf", helperTy);
 
-          std::vector<Value *> call_args = {call_instr->getOperand(0), call_instr->getOperand(1), call_instr};
 
           IRBuilder<> builder(call_instr);
           builder.SetInsertPoint(call_instr->getNextNode());
+          auto *size = builder.CreateIntCast(call_instr, int32Ty, false);
+
+          std::vector<Value *> call_args = {call_instr->getOperand(0), call_instr->getOperand(1), size};
           builder.CreateCall(helper, call_args);
 
         }
@@ -620,10 +700,13 @@ bool AFLCoverage::runOnModule(Module &M) {
           auto * helperTy = FunctionType::get(voidTy, { int8PtrTy, int8PtrTy, int32Ty, int32Ty }, false);
           auto helper = M.getOrInsertFunction("trace_fwrite", helperTy);
 
-          std::vector<Value *> call_args = {call_instr->getOperand(3), call_instr->getOperand(0), call_instr->getOperand(1), call_instr->getOperand(2)};
 
           IRBuilder<> builder(call_instr);
           //builder.SetInsertPoint(call_instr->getNextNode());
+          auto *size = builder.CreateIntCast(call_instr->getOperand(1), int32Ty, false);
+          auto *ntimes = builder.CreateIntCast(call_instr->getOperand(2), int32Ty, false);
+          std::vector<Value *> call_args = {call_instr->getOperand(3), call_instr->getOperand(0), size, ntimes};
+
           builder.CreateCall(helper, call_args);
 
         }
@@ -637,10 +720,13 @@ bool AFLCoverage::runOnModule(Module &M) {
           auto * helperTy = FunctionType::get(voidTy, { int8PtrTy, int8PtrTy, int32Ty, int32Ty }, false);
           auto helper = M.getOrInsertFunction("trace_fread", helperTy);
 
-          std::vector<Value *> call_args = {call_instr->getOperand(3), call_instr->getOperand(0), call_instr->getOperand(1), call_instr->getOperand(2)};
 
           IRBuilder<> builder(call_instr);
           //builder.SetInsertPoint(call_instr->getNextNode());
+          auto *size = builder.CreateIntCast(call_instr->getOperand(1), int32Ty, false);
+          auto *ntimes = builder.CreateIntCast(call_instr->getOperand(2), int32Ty, false);
+
+          std::vector<Value *> call_args = {call_instr->getOperand(3), call_instr->getOperand(0), size, ntimes};
           builder.CreateCall(helper, call_args);
 
         }
@@ -706,6 +792,8 @@ bool AFLCoverage::runOnModule(Module &M) {
       IRBuilder<> builder(call_instr);
 
       // test if allocated stack size is greater or equal than threshold
+      // call_instr->dump();
+      // call_instr->getOperand(0)->dump();
       auto stack_size_cmp = builder.CreateICmpUGE(call_instr->getOperand(0), ConstantInt::get(int64Ty, MIN_STACK_ALLOC_SIZE));
       auto split_before = SplitBlockAndInsertIfThen(stack_size_cmp, call_instr, false);
       builder.SetInsertPoint(split_before);
@@ -736,21 +824,51 @@ bool AFLCoverage::runOnModule(Module &M) {
 
   }
 
-  return true;
+  return PreservedAnalyses::none();
 
 }
 
+                 /* use new pass manager */
+extern "C" ::llvm::PassPluginLibraryInfo LLVM_ATTRIBUTE_WEAK
+llvmGetPassPluginInfo() {
 
-static void registerAFLPass(const PassManagerBuilder &,
-                            legacy::PassManagerBase &PM) {
+  return {LLVM_PLUGIN_API_VERSION, "AFLCoverage", "v0.1",
+          /* lambda to insert our pass into the pass pipeline. */
+          [](PassBuilder &PB) {
 
-  PM.add(new AFLCoverage());
+  #if 1
+    #if LLVM_VERSION_MAJOR <= 13
+            using OptimizationLevel = typename PassBuilder::OptimizationLevel;
+    #endif
+            PB.registerOptimizerLastEPCallback(
+                [](ModulePassManager &MPM, OptimizationLevel OL) {
 
-}
+                  MPM.addPass(AFLCoverage());
+
+                });
+
+  /* TODO LTO registration */
+  #else
+            using PipelineElement = typename PassBuilder::PipelineElement;
+            PB.registerPipelineParsingCallback([](StringRef          Name,
+                                                  ModulePassManager &MPM,
+                                                  ArrayRef<PipelineElement>) {
+
+              if (Name == "AFLCoverage") {
+
+                MPM.addPass(AFLCoverage());
+                return true;
+
+              } else {
+
+                return false;
+
+              }
+
+            });
 
+  #endif
 
-static RegisterStandardPasses RegisterAFLPass(
-    PassManagerBuilder::EP_ModuleOptimizerEarly, registerAFLPass);
+          }};
 
-static RegisterStandardPasses RegisterAFLPass0(
-    PassManagerBuilder::EP_EnabledOnOptLevel0, registerAFLPass);
+}
\ No newline at end of file
diff --git a/llvm_mode/afl-llvm-rt-state-tracer.o.c b/llvm_mode/afl-llvm-rt-state-tracer.o.c
index 65290a9..4b56f2a 100644
--- a/llvm_mode/afl-llvm-rt-state-tracer.o.c
+++ b/llvm_mode/afl-llvm-rt-state-tracer.o.c
@@ -1,3 +1,4 @@
+#include <bits/types/struct_iovec.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <signal.h>
@@ -202,18 +203,27 @@ static int compare_int(const void *const one, const void *const two) {
 }
 
 
-static Tlsh * __dist_t1;
-static Tlsh * __dist_t2;
-
 static float tlsh_distance(MVPDP *pointA, MVPDP *pointB){
+    float diff = 0.0;
+    Tlsh * __dist_t1;
+    Tlsh * __dist_t2;
+
+    __dist_t1 = Tlsh_new();
+    __dist_t2 = Tlsh_new();
+
+    // Tlsh_from_str(__dist_t1, "xxx");
+    // Tlsh_from_str(__dist_t2, "yyy");
 
     Tlsh_from_str(__dist_t1, pointA->data);
     Tlsh_from_str(__dist_t2, pointB->data);
 
-    int diff = Tlsh_total_diff(__dist_t1, __dist_t2, 1/*len_diff*/);
+    //int diff = Tlsh_total_diff(__dist_t1, __dist_t2, 1/*len_diff*/);
 
     LOG_DEBUG("TLSH DISTANCE: %d\n", diff);
 
+    Tlsh_delete(__dist_t1);
+    Tlsh_delete(__dist_t2);
+
     return (float)diff;
 }
 
@@ -382,7 +392,7 @@ void init_state_tracer() {
     // For testing
     state_shared_ptr = malloc(sizeof(struct state_shared));
 
-    LOG_DEBUG("NO SHM (for testing)\n");
+    LOG_DEBUG("NO state_shared_ptr (for testing)\n");
   }
 
 
@@ -577,8 +587,7 @@ next_item_global:
     mvp_radius_default = atoi(mvp_str);
   }
 
-
-  if(getenv("AFL_USE_ASAN") || getenv("ASAN_OPTIONS")) {
+  if(1 || getenv("AFL_USE_ASAN") || getenv("ASAN_OPTIONS")) {
 
     LOG_DEBUG("ASAN DETECTED\n");
 
@@ -985,6 +994,7 @@ static void tracer_dump() {
 
 
   void ** key = map_first(alloc_records_map);
+  int null_fd = open("/dev/null", O_WRONLY);
 
   while( key != NULL ) {
 
@@ -1001,7 +1011,12 @@ static void tracer_dump() {
       dump.record = record;
       dump.contents = malloc(record->size);
       dump.size = record->size;
-      memcpy(dump.contents, record->addr, record->size);
+
+      if (null_fd > 0) {
+        if (write(null_fd, record->addr, record->size) != -1) {
+          memcpy(dump.contents, record->addr, record->size);
+        }
+      }
 
       queue_push(alloc_dumps_queue, &dump);
 
@@ -1161,6 +1176,19 @@ void trace_read(int fd, void * buf, int size) {
   END_TIMING("read");
 }
 
+void trace_readv(int fd, const struct iovec *iov, int iovcnt) {
+  LOG_DEBUG("TRACE READV\n");
+
+  if (is_socket(fd)) {
+    for (int i = 0; i < iovcnt; i++) {
+      const struct iovec *iovec = &iov[i];
+      net_receive(iovec->iov_base, iovec->iov_len);
+    }
+  }
+
+}
+
+
 void trace_write(int fd, void * buf, int size) {
 
   LOG_DEBUG("TRACE WRITE\n");
@@ -1174,6 +1202,18 @@ void trace_write(int fd, void * buf, int size) {
   END_TIMING("write");
 }
 
+void trace_writev(int fd, const struct iovec *iov, int iovcnt) {
+  LOG_DEBUG("TRACE WRITEV\n");
+
+  if (is_socket(fd)) {
+    for (int i = 0; i < iovcnt; i++) {
+      const struct iovec *iovec = &iov[i];
+      net_send(iovec->iov_base, iovec->iov_len);
+    }
+  }
+
+}
+
 void trace_fprintf(void* p, void * buf, int size) {
 
   LOG_DEBUG("TRACE FPRINTF\n");
@@ -1352,7 +1392,7 @@ unsigned int compute_state_value(Tlsh * t, int data_size, MVPTree * tree, unsign
 
         Tlsh_from_str(ref_tlsh, calib_shm->ref_state_seq[current_state_number]);
 
-        int diff = Tlsh_total_diff(ref_tlsh, t, 1/*len_diff*/);
+        int diff = 1; //Tlsh_total_diff(ref_tlsh, t, 1/*len_diff*/);
 
         LOG_DEBUG("TLSH DISTANCE FROM REF: %d\n", diff);
 
@@ -1580,9 +1620,6 @@ void end_state_tracer() {
   Tlsh * tlsh = Tlsh_new();
   int curr_state_buffer_data = 0;
 
-  __dist_t1 = Tlsh_new();
-  __dist_t2 = Tlsh_new();
-
 
 
   for(int i=0; i<num_dumps; i++) {
@@ -1870,9 +1907,6 @@ void end_state_tracer() {
   free(tree);
 
   Tlsh_delete(tlsh);
-  Tlsh_delete(__dist_t1);
-  Tlsh_delete(__dist_t2);
-
 
 end_analysis:
 
